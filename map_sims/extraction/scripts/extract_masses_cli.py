"""Command-line tool to start extract aperture masses from projected
mass maps generated by map_sims.generation.save_full_map_full.

Usage: python compute_masses.cli.py map_names_file info_names_file

map_names_file should contain filenames saved by map_sims.generation.save_full_map_full()
info_names_file should contain filenames saved by map_sims.sims.sim.save_halo_info_file()
"""
#!/usr/bin/env python3

import argparse
import os
import logging
from multiprocessing import Pool
import time
import traceback

import astropy.units as u
import gadget
import mira_titan
import numpy as np
import simulation_slices.tasks as tasks
import toml

import map_sims.extraction.aperture_masses as extraction
import map_sims.tools as tools


RHO_CRIT = 2.7763458 * (10.0 ** 11.0) * u.littleh ** 2 * u.Msun / u.Mpc ** 3
parser = argparse.ArgumentParser(
    description="Extract aperture masses from all maps in map_names_file with metadata in matching info_names_file."
)
parser.add_argument(
    "map_names_file",
    default="",
    type=str,
    help="file with all maps files filenames",
)
parser.add_argument(
    "info_names_file",
    default="",
    type=str,
    help="file with all info_file filenames.",
)
parser.add_argument(
    "-n",
    "--max_cpus",
    default=1,
    type=int,
    help="maximum number of concurrent processes",
)
parser.add_argument(
    "--sim_suite",
    default="MiraTitan",
    type=str,
    help="simulation suite to analyse",
)
parser.add_argument(
    "--base_dir",
    default="/cosmo/scratch/projects/MiraTitanU/Grid/",
    type=str,
    help="base directory for simulations",
)
parser.add_argument(
    "--log_dir",
    default="/cosmo/scratch/debackere/logs/",
    type=str,
    help="location to save log file",
)
parser.add_argument(
    "--radii_file",
    default="/cosmo/scratch/debackere/batch_files/r_0p5-1p5_r2_0p5-2p0_rm_3p0.toml",
    type=str,
    help="toml file containing the section 'radii' with keys r_aps, r_ins and r_out",
)
parser.add_argument("--overwrite", dest="overwrite", action="store_true")
parser.add_argument("--no-overwrite", dest="overwrite", action="store_false")
parser.set_defaults(overwrite=False)


def extract_fnames(file_path):
    with open(file_path, "r") as f:
        fnames = [l.rstrip("\n") for l in f]

    return fnames


def main():
    t0 = time.time()
    args = parser.parse_args()

    base_dir = args.base_dir
    log_dir = args.log_dir
    sim_suite = args.sim_suite
    info_files = extract_fnames(args.info_names_file)
    map_files = extract_fnames(args.map_names_file)
    radii_file = args.radii_file
    overwrite = args.overwrite

    log_fname = f"{log_dir}/save_aperture_masses_{os.getpid()}"
    logger = tools.get_logger(fname=log_fname, log_level="info")

    if sim_suite.lower() == "bahamas":
        R_unit = u.Mpc / u.littleh
        extra_dsets = {
            "m200m": "masses",
            "m500c": "FOF/Group_M_Crit500",
            "m200c": "FOF/Group_M_Crit200",
        }
    elif sim_suite.lower() == "miratitan":
        R_unit = u.Mpc
        extra_dsets = {
            "m200c": "masses",
        }
    else:
        raise ValueError(f"{sim_suite=} not recognized")

    radii = toml.load(radii_file)["radii"]
    R_aps = np.atleast_1d(radii["r_aps"]) * R_unit
    R2s = np.atleast_1d(radii["r_ins"]) * R_unit
    Rms = np.atleast_1d(radii["r_out"]) * R_unit

    cut_map_size = max((2 * R_aps.max(), (2 * Rms.max()) or 0))

    kwargs = {
        "extra_dsets": extra_dsets,
        "r_aps": R_aps,
        "r2s": R2s,
        "rms": Rms,
        "overwrite": overwrite,
        "verbose": False,
        "sim_suite": sim_suite,
        "calc_bg": True,
        "cut_map_size": cut_map_size,
        "logger": logger,
    }

    batch_parameters = []
    # ensure that mira_titan does not claim all resources
    for map_file in map_files:
        map_file_split = map_file.split("/")

        save_dir = "/".join(map_file_split[:-1])
        sim_name = map_file_split[-2]
        if not map_file_split[-1].endswith(".hdf5"):
            raise ValueError(f"{map_file} should be .hdf5 file.")

        # strip .hdf5 extension => {slice_axis}_{map_name}_{snapshot:03d}
        map_name = map_file_split[-1][:-5]

        # get snapshot from map_file
        snapshot = int(map_name[-3:])

        # get slice_axis from map_file
        slice_axis = int(map_name[0])

        info_file = None
        for f in info_files:
            if sim_name in f and str(snapshot) in f:
                info_file = f
                break

        if info_file is None:
            logger.warning(f"no matching info_file for {map_file=} found in {info_file=}")
            with open(f"{log_fname}_{sim_name}_{snapshot:03d}.missing", "w") as f:
                f.write(f"no matching info_file for {map_file=} found in {info_file=}")

            # skip this map_file
            continue

        info_file_split = info_file.split("/")
        if not info_file_split[-1].endswith(".hdf5"):
            raise ValueError(f"{info_file} should be .hdf5 file.")

        # get rid of .hdf5 extension
        info_name = info_file_split[-1][:-5]

        if R2s is not None and Rms is not None:
            ann_str = (
                f"_R2s_{str(np.round(R2s.min().value, 2)).replace('.', 'p')}-"
                f"{str(np.round(R2s.max().value, 2)).replace('.', 'p')}_"
                f"Rms_{str(np.round(Rms.min().value, 2)).replace('.', 'p')}-"
                f"{str(np.round(Rms.max().value, 2)).replace('.', 'p')}_"
            )
        else:
            ann_str = ""

        save_fname = f"{save_dir}/{map_name[:-4]}_aperture_masses{ann_str}{info_name}.hdf5"

        # only need this for cosmology
        if sim_suite.lower() == "miratitan":
            sim_info = mira_titan.MiraTitan(
                sim_dir=f"{base_dir}/{sim_name}/",
                snapnum=401,
            )
            rho_mean = sim_info.cosmo["omega_m"] * RHO_CRIT.to(
                u.Msun / u.Mpc ** 3,
                equivalencies=u.with_H0(100 * sim_info.cosmo["h"] * u.km / (u.s * u.Mpc)),
            )
        elif sim_suite.lower() == "bahamas":
            sim_info = gadget.Gadget(
                model_dir=f"{base_dir}/{sim_name}/",
                file_type="snap",
                snapnum=28,
            )
            rho_mean = sim_info.omega_m * RHO_CRIT.to(
                u.littleh**2 * u.Msun / u.Mpc ** 3,
                equivalencies=u.with_H0(100 * sim_info.h * u.km / (u.s * u.Mpc)),
            )
        else:
            raise ValueError(f"{sim_suite=} should be BAHAMAS or MiraTitan")

        kwargs = {
            **kwargs,
            "fname": save_fname,
            "sim": sim_name,
            "snapshot": snapshot,
            "info_file": info_file,
            "map_file": map_file,
            "rho_mean": rho_mean,
            "slice_axis": slice_axis,
        }
        batch_parameters.append(kwargs)
        logger.info(f"kwargs for {sim_name}_{snapshot:03d}_{slice_axis} loaded")

    # let sbatch handle multiprocessing
    if args.max_cpus == 1:
        for prms in batch_parameters:
            logger.info(f"submitting {prms['map_file']}")
            try:
                extraction.save_aperture_masses(**prms)
            except Exception:
                logger.error(f"{prms['fname']} failed with exception", exc_info=True)
                sim = prms["sim"]
                snap = prms["snapshot"]
                with open(f"{log_fname}_{sim}_{snap:03d}.err", "w") as f:
                    f.write(traceback.format_exc())

    # without sbatch, run multiprocessing through python
    elif args.max_cpus > 1:
        with Pool(args.max_cpus) as pool:
            future_parameters = [
                (pool.apply_async(extraction.save_aperture_masses, kwds=prms), prms)
                for prms in batch_parameters
            ]
            for future, prms in future_parameters:
                try:
                    future.get()
                except Exception:
                    logger.error(f"{prms['fname']} failed with exception", exc_info=True)
                    sim = prms["sim"]
                    snap = prms["snapshot"]
                    with open(f"{log_fname}_{sim}_{snap:03d}.err", "w") as f:
                        f.write(traceback.format_exc())

    tf = time.time()
    logger.info(f"Full analysis took {tf-t0:.2f}s")


if __name__ == "__main__":
    main()
